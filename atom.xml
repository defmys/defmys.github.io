<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[钟表匠]]></title>
  <link href="http://defmys.github.io/atom.xml" rel="self"/>
  <link href="http://defmys.github.io/"/>
  <updated>2016-02-19T12:15:29+08:00</updated>
  <id>http://defmys.github.io/</id>
  <author>
    <name><![CDATA[Ma Tingchen]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Coding Style]]></title>
    <link href="http://defmys.github.io/blog/2016/02/18/coding-style/"/>
    <updated>2016-02-18T15:32:45+08:00</updated>
    <id>http://defmys.github.io/blog/2016/02/18/coding-style</id>
    <content type="html"><![CDATA[<p>
最近在整理前段时间写的代码。之前一直使用IDE进行检查，我使用的是PyCharm，能够使代码基本满足PEP8的要求。但还是有一些例外。利用其他工具检查的时候就能发现一些问题。我一直觉得代码必须要遵循一定的规则，以增强可读性。曾经看到过一句话，大概是说，代码是给人看的，至于如何让机器理解，那是编译器的工作。一般情况下公司对代码都会有一定的要求，不过是否严格执行就不一定了。在没有严格要求的情况下，纯靠自觉。。<br />
<ul>
    <li>C++可以参考<a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></li>
    <li>Python主要参考<a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a> </li>
</ul>
</p>




<h2>PEP8</h2>


<p>
PEP8涵盖了命名规则、缩进、行长度等规则，也有不少工具可以自动进行检查。
</p>


<p>
其中比较有争议的是单行的最大长度。PEP8中规定一行代码的最大长度为79个字符，如果项目组内可以达成共识，可将长度扩展到99个字符。有一些编辑器默认会将行长度限制到80字符，超出限制之后会自动换行。换行之后代码会变得非常乱，影响阅读。将行长度限制到79个字符而不是80个字符是因为部分编辑器会显示出行尾的换行符，当一行有80个字符时，加上最后这个换行符，就会变成81个字符。这种情况下，编辑器可能会自动换行。另外，我也搜到了一些其他的文章，讨论“80个字符”这个限制的各种原因，包括终端显示、人阅读时的行为习惯等等。
</p>


<p>
将代码限制到79个字符是一个比较痛苦过程。PyCharm默认限制为120个字符，我也一直是按120字符去进行换行。重新限制了长度之后，有几百处代码需要修改。但修改完之后发现还是有很多好处的。比如可以同时开两个vim放在屏幕左右两边，阅读代码时不需要左右滚动；PyCharm中也可以左右开两个标签页；阅读时眼睛基本集中在一片区域等等。目前项目中还没有遇到无法修改到79个字符以内的代码。
</p>


<p>
至于其他规则，目前感觉没什么好纠结的。
</p>




<h2>Flake8</h2>


<p>
Flake8是一个执行python代码检查的工具集合。目前我使用Flake8来对项目代码进行检查。除PEP8之外，Flake8还会执行一些额外的检查。可以通过命令行参数调整flake8的行为，也可以将参数写入配置文件中。项目的setup.cfg中如果存在[flake8]的配置，flake8会自动读取这些配置。例如我们的setup.cfg文件中：
<figure class='code'><figcaption><span>setup.cfg</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[flake8]</span>
</span><span class='line'><span class="na">exclude</span> <span class="o">=</span> <span class="s">some_dir/*</span>
</span><span class='line'><span class="na">max-complexity</span> <span class="o">=</span> <span class="s">10</span>
</span></code></pre></td></tr></table></div></figure>
检查时会跳过some_dir，同时开启复杂度检查（默认是关闭的），允许的最大复杂度为10。
</p>


<p>
可以把flake8做成hook，提交代码之后自动进行检查。我们的项目一直使用jenkins做一些自动化的工作，任何一个任务执行失败之后会自动发邮件给相关人员，也能看到具体执行的命令和输出，非常方便。所以我直接把检查的步骤交给jenkins去做，每半个小时检查一次svn是否有更新，如果有更新，执行一次检查，如果出现错误，自动给这段时间提交过代码的人发邮件。
</p>




<h2>McCabe复杂度</h2>


<p>
Flake8中集成了<a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">McCabe复杂度（循环复杂度）</a>检查，默认情况下是关闭的。循环复杂度是一段代码中线性独立路径的数量。例如，一段代码中存在一个if语句，那么就存在true和false两种情况，对应就有两条路径。<br />
循环复杂度M定义为：<br /><br />
<strong>M = E - N + 2P</strong><br />
<img class="right" src="http://defmys.github.io/images/Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg" width="192" height="240" title="complexity example" >
<ul>
其中：
<li>E = 图中边的数量</li>
<li>N = 图中顶点的数量</li>
<li>P = 图中连通分支的数量</li>
</ul>
<br />

借用wikipedia中的一个例子：<br>

右图中有9条边，8个顶点，1个连通分支。E=9，N=8，P=1，所以循环复杂度M = 9 - 8 + 2*1 = 3
</p>




<p>
我们项目的代码使用MVC模式。View纯粹是前端的工作，对于只提供API的后端来说，只有M与C。Model与Model之间基本无耦合，逻辑比较清晰，在检查复杂度的时候基本没有问题，偶尔有一两处复杂度达到了11或12，简单修改之后就能降低到10以下。问题在于Controller。Controller将不同的Model在逻辑上联系在一起，对于逻辑上稍复杂一些的Controller，代码很容易写的很长，分支也很多。检查之后发现，复杂度高的基本都是Controller，最大的能达到26。写代码的时候没什么感觉，但是回过头再看这些代码的时候，发现真的是又长又难理解。经过一番重构之后，最终把所有代码的复杂度都降到了10以下。这样的重构带来的好处是使代码变得清晰易懂。我一直希望自己写的代码能满足self-documenting code的要求，简单易懂好维护，无需多余的注释。通过这次重构，我发现在降低复杂度的同时，代码能向着self-documenting的方向更进一步。降低复杂度时我将大段的、逻辑上可分离的分支抽取成函数，函数名即可表名这段代码的作用。逻辑主干上看到的只是这个函数名，而实现细节被封装了起来。阅读时看到函数名就等于是看到了一行注释，比直接阅读实现细节要清晰明了。
</p>




<h2></h2>


<p>
规范代码风格有时是一个比较痛苦的过程，但是带来的收益却是可观的。偶尔犯懒，对于不好修改的代码，总想加个例外。但静下心来修改完之后，再看这段代码，会发现其实并没有什么例外。自己认为不好修改的部分，很多时候其实是原本的实现存在问题。
<strong><em>Special cases aren't special enough to break the rules.</em></strong>
</p>


<p><br /></p>

<p>
最后，附上 The Zen of Python
<blockquote><p>Beautiful is better than ugly.<br/>Explicit is better than implicit.<br/>Simple is better than complex.<br/>Complex is better than complicated.<br/>Flat is better than nested.<br/>Sparse is better than dense.<br/>Readability counts.<br/>Special cases aren't special enough to break the rules.<br/>Although practicality beats purity.<br/>Errors should never pass silently.<br/>Unless explicitly silenced.<br/>In the face of ambiguity, refuse the temptation to guess.<br/>There should be one-- and preferably only one --obvious way to do it.<br/>Although that way may not be obvious at first unless you're Dutch.<br/>Now is better than never.<br/>Although never is often better than *right* now.<br/>If the implementation is hard to explain, it's a bad idea.<br/>If the implementation is easy to explain, it may be a good idea.<br/>Namespaces are one honking great idea -- let's do more of those!</p><footer><strong>The Zen of Python</strong> <cite><a href='https://www.python.org/dev/peps/pep-0020/'>PEP20</a></cite></footer></blockquote>
</p>




<h2>参考</h2>


<ul>
<li><a href="https://www.python.org/dev/peps/pep-0008/">PEP 0008 -- Style Guide for Python Code</a></li>
<li><a href="https://flake8.readthedocs.org/en/latest/">Flake8</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic complexity</a></li>
<li><a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">Connected component (graph theory)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Self-documenting_code">https://en.wikipedia.org/wiki/Self-documenting_code</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0020/">PEP 20 -- The Zen of Python</a></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Metaclass]]></title>
    <link href="http://defmys.github.io/blog/2016/01/05/metaclass/"/>
    <updated>2016-01-05T10:36:01+08:00</updated>
    <id>http://defmys.github.io/blog/2016/01/05/metaclass</id>
    <content type="html"><![CDATA[<p>
在Python中，任何东西都是对象。函数是对象，类也是对象，类的类也是对象。
<figure class='code'><figcaption><span>Example0.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'><span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
</span><span class='line'><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

输出：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>&lt;class <span class="s1">&#39;function&#39;</span>&gt;
</span><span class='line'>&lt;class <span class="s1">&#39;type&#39;</span>&gt;
</span><span class='line'>&lt;class <span class="s1">&#39;type&#39;</span>&gt;
</span></code></pre></td></tr></table></div></figure>

可以看到，foo是function的对象，function是type的对象，type是type的对象。
</p>


<h2>type</h2>


<p>type是python中的一个builtin类，并非关键字(<a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">Python Keywords</a>)。<br />
有两种方式可以调用type，分别产生两种效果:</p>

<pre><code>* 当只有一个参数时，也就是上面例子中的用法，type返回参数中对象的类
* 当有三个参数时，type生成一个新的类。
</code></pre>

<p>我们只看第一种用法。以下是python3.5.1中的C实现：</p>

<figure class='code'><figcaption><span>typeobject.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="nf">type_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">metatype</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 省略部分代码</span>
</span><span class='line'>    <span class="cm">/* Special case: type(x) should return x-&gt;ob_type */</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">const</span> <span class="n">Py_ssize_t</span> <span class="n">nargs</span> <span class="o">=</span> <span class="n">PyTuple_GET_SIZE</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span><span class='line'>        <span class="k">const</span> <span class="n">Py_ssize_t</span> <span class="n">nkwds</span> <span class="o">=</span> <span class="n">kwds</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">PyDict_Size</span><span class="p">(</span><span class="n">kwds</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PyType_CheckExact</span><span class="p">(</span><span class="n">metatype</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nkwds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">PyObject</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="cm">/* SF bug 475327 -- if that didn&#39;t trigger, we need 3</span>
</span><span class='line'><span class="cm">           arguments. but PyArg_ParseTupleAndKeywords below may give</span>
</span><span class='line'><span class="cm">           a msg saying type() needs exactly 3. */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">nargs</span> <span class="o">+</span> <span class="n">nkwds</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
</span><span class='line'>                            <span class="s">&quot;type() takes 1 or 3 arguments&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 省略部分代码</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到这里有一个特殊处理：当只args中只有一个参数时，type(x)会直接返回这一个参数的类。</p>




<h2>Metaclass</h2>


<p>通过type，我们可以知道一个对象的类究竟是什么。从第一个例子中可以看出，函数是function类的对象，类是type类的对象，type类自己也是type类的对象。<strong>类的类就是metaclass</strong>。</p>


<p>如果我们在创建一个类时，没有特别指明一个metaclass，那么这个类就会使用type类作为自己的metaclass。</p>


<p>类决定了对象的行为，同理，作为类的类，metaclass决定了一个类在生成对象时的行为。</p>




<p>
metaclass可以是任何可被调用的类型，类或者函数都可以。<br />
Python3为metaclass引入了一个新的函数:<strong>&#95;&#95;prepare&#95;&#95;</strong>，这个函数会在对象创建前被调用并返回一个字典。这个字典不一定是内置的dict，只要实现了部分必须的接口就可以。这个字典中存储了对象的成员。由于可以是自己实现的dict，我们可以对其进行各种操作。
</p>


<p>所以，通过&#95;&#95;prepare&#95;&#95;, &#95;&#95;new&#95;&#95;, &#95;&#95;init&#95;&#95;等函数，我们可以控制生成对象时的一些行为。</p>


<p>以下是PEP3115中的例子，最后稍做了一点改动，用来输出结果：</p>

<figure class='code'><figcaption><span>PEP3115_Example1.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='python3'><span class='line'><span class="c"># Here&#39;s a simple example of a metaclass which creates a list of</span>
</span><span class='line'><span class="c"># the names of all class members, in the order that they were</span>
</span><span class='line'><span class="c"># declared:</span>
</span><span class='line'>
</span><span class='line'><span class="c"># The custom dictionary</span>
</span><span class='line'><span class="k">class</span> <span class="nc">member_table</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">member_names</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># if the key is not already defined, add to the</span>
</span><span class='line'>        <span class="c"># list of keys.</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">member_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Call superclass</span>
</span><span class='line'>        <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c"># The metaclass</span>
</span><span class='line'><span class="k">class</span> <span class="nc">OrderedClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># The prepare function</span>
</span><span class='line'>    <span class="nd">@classmethod</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="n">metacls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span> <span class="c"># No keywords in this case</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">member_table</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># The metaclass invocation</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># Note that we replace the classdict with a regular</span>
</span><span class='line'>        <span class="c"># dict before passing it to the superclass, so that we</span>
</span><span class='line'>        <span class="c"># don&#39;t continue to record member names after the class</span>
</span><span class='line'>        <span class="c"># has been created.</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">classdict</span><span class="p">))</span>
</span><span class='line'>        <span class="n">result</span><span class="o">.</span><span class="n">member_names</span> <span class="o">=</span> <span class="n">classdict</span><span class="o">.</span><span class="n">member_names</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">OrderedClass</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># method1 goes in array element 0</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">method1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># method2 goes in array element 1</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">method2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">MyClass</span><span class="p">()</span><span class="o">.</span><span class="n">member_names</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="o">[</span><span class="s1">&#39;__module__&#39;</span>, <span class="s1">&#39;__qualname__&#39;</span>, <span class="s1">&#39;method1&#39;</span>, <span class="s1">&#39;method2&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>该例子中：</p>

<pre><code>1. 创建了一个member_table，继承自dict并重载了__setitem__函数，按顺序记录所有key。
2. 声明了一个新的metaclass -- OrderedClass。
    2.1 __prepare__函数返回一个member_table对象
    2.2 __new__函数中将member_table里记录的key复制给自己的一个成员变量member_names。
3. 申明了一个metaclass为OrderedClass的类，声明两个成员函数。这两个成员函数的名称会被存储在member_names中。
</code></pre>

<p>当一个对象被创建时，以下工作会被按顺序执行</p>

<blockquote><p>When a class definition is executed, the following steps occur:</p><p>    * the appropriate metaclass is determined<br/>    * the class namespace is prepared<br/>    * the class body is executed<br/>    * the class object is created</p><footer><strong>docs.python.org</strong> <cite><a href='https://docs.python.org/3/reference/datamodel.html#customizing-class-creation'>Customizing Class Creation</a></cite></footer></blockquote>




<p>以下是对应的代码：
<figure class='code'><figcaption><span>Lib/types.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="c"># Provide a PEP 3115 compliant mechanism for class creation</span>
</span><span class='line'><span class="k">def</span> <span class="nf">new_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwds</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">exec_body</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;Create a class object dynamically using the appropriate metaclass.&quot;&quot;&quot;</span>
</span><span class='line'>    <span class="n">meta</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">kwds</span> <span class="o">=</span> <span class="n">prepare_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">exec_body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="k">None</span><span class="p">:</span>
</span><span class='line'>        <span class="n">exec_body</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">meta</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">prepare_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwds</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;Call the __prepare__ method of the appropriate metaclass.</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    Returns (metaclass, namespace, kwds) as a 3-tuple</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    *metaclass* is the appropriate metaclass</span>
</span><span class='line'><span class="sd">    *namespace* is the prepared class namespace</span>
</span><span class='line'><span class="sd">    *kwds* is an updated copy of the passed in kwds argument with any</span>
</span><span class='line'><span class="sd">    &#39;metaclass&#39; entry removed. If no kwds argument is passed in, this will</span>
</span><span class='line'><span class="sd">    be an empty dict.</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">kwds</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
</span><span class='line'>        <span class="n">kwds</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span> <span class="c"># Don&#39;t alter the provided mapping</span>
</span><span class='line'>    <span class="k">if</span> <span class="s">&#39;metaclass&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
</span><span class='line'>        <span class="n">meta</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;metaclass&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">bases</span><span class="p">:</span>
</span><span class='line'>            <span class="n">meta</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'>        <span class="k">else</span><span class="p">:</span>
</span><span class='line'>            <span class="n">meta</span> <span class="o">=</span> <span class="nb">type</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># when meta is a type, we first determine the most-derived metaclass</span>
</span><span class='line'>        <span class="c"># instead of invoking the initial candidate directly</span>
</span><span class='line'>        <span class="n">meta</span> <span class="o">=</span> <span class="n">_calculate_meta</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="s">&#39;__prepare__&#39;</span><span class="p">):</span>
</span><span class='line'>        <span class="n">ns</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">__prepare__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">ns</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">meta</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">kwds</span>
</span></code></pre></td></tr></table></div></figure>

以上代码解释了metaclass中的&#95;&#95;prepare&#95;&#95;在何时被调用以及完成了哪些工作。</p>




<p>再简单看一下metaclass在type_new函数中如何工作。以下代码只保留了我们关心的部分。
<figure class='code'><figcaption><span>typeobject.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="nf">type_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">metatype</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// ..........................</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Determine the proper metatype to deal with this: */</span>
</span><span class='line'>    <span class="n">winner</span> <span class="o">=</span> <span class="n">_PyType_CalculateMetaclass</span><span class="p">(</span><span class="n">metatype</span><span class="p">,</span> <span class="n">bases</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">winner</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">winner</span> <span class="o">!=</span> <span class="n">metatype</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">winner</span><span class="o">-&gt;</span><span class="n">tp_new</span> <span class="o">!=</span> <span class="n">type_new</span><span class="p">)</span> <span class="cm">/* Pass it to the winner */</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">winner</span><span class="o">-&gt;</span><span class="n">tp_new</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">);</span>
</span><span class='line'>        <span class="n">metatype</span> <span class="o">=</span> <span class="n">winner</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// ............................</span>
</span><span class='line'>
</span><span class='line'>     <span class="cm">/* Allocate the type object */</span>
</span><span class='line'>    <span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="p">)</span><span class="n">metatype</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">metatype</span><span class="p">,</span> <span class="n">nslots</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// ..............................</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

首先还是选取一个合适的metaclass，如果选出的metaclass不是当前参数中的metatype，那么执行选出的metatype->tp_new。然后为类申请空间、进行初始化工作。最后返回该类。</p>




<h2>实践</h2>


<p>最后，我们用metaclass来实现一个简单的singleton。
<figure class='code'><figcaption><span>Example2.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">class</span> <span class="nc">Singleton</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span class='line'>    <span class="n">instance</span> <span class="o">=</span> <span class="k">None</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span class='line'>        <span class="k">if</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
</span><span class='line'>            <span class="n">cls</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ASingleton</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Singleton</span><span class="p">):</span>
</span><span class='line'>    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">BSingleton</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Singleton</span><span class="p">):</span>
</span><span class='line'>    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">a1</span> <span class="o">=</span> <span class="n">ASingleton</span><span class="p">()</span>
</span><span class='line'>    <span class="n">a2</span> <span class="o">=</span> <span class="n">ASingleton</span><span class="p">()</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;a1 is a2? %s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a1</span> <span class="ow">is</span> <span class="n">a2</span><span class="p">))</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">a2</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;===============&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">BSingleton</span><span class="p">()</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;a1 is b? %s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a1</span> <span class="ow">is</span> <span class="n">b</span><span class="p">))</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

输出：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>a1 is a2? True
</span><span class='line'>ASingleton
</span><span class='line'><span class="nv">ASingleton</span>
</span><span class='line'><span class="o">===============</span>
</span><span class='line'>a1.instance is ASingleton.instance?
</span><span class='line'><span class="nv">True</span>
</span><span class='line'><span class="o">===============</span>
</span><span class='line'>a1 is b? False
</span><span class='line'>BSingleton
</span></code></pre></td></tr></table></div></figure>

</p>


<p>
在这个例子中，我们创建了一个名为Singleton的metaclass。Singleton带有一个静态成员变量instance。在调用ASingleton或BSingleton创建对象时，会先检查instance是否为空。<br />需要注意的是，在第一次调用时，我们访问的是metaclass的静态成员变量instance。当对象被创建出来之后，这个对象会被赋值给各自class的instance（注意__call__的第一个参数 cls）。之后再通过ASingleton或BSingleton创建对象时，访问的是它们各自的类的instance，而不是metaclass的instance。<br />另外，由于使用的是类的instance，即相当于该class的静态成员变量，而不是生成出的对象的成员变量，所以相同的类的object所访问的都是同一个instance。
</p>




<h2></h2>


<h4>参考：</h4>


<ul>
<li><a href="https://www.python.org/dev/peps/pep-3115/">PEP 3115 -- Metaclasses in Python 3000</a></li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation">Data model - Python 3.5.1 documentation</a></li>
<li><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">oop - What is a metaclass in Python? - Stack Overflow</a></li>
<li><a href="http://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">Understanding Python metaclasses | ionel's codelog</a></li>
<li><a href="https://en.wikibooks.org/wiki/Python_Programming/Metaclasses">Python Programming/Metaclasses - Wikibooks, open books for an open world</a></li>
<li><a href="http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html">Metaprogramming - Python 3 Patterns, Recipes and Idioms</a></li>
</ul>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[__new__ &amp;&amp; __init__]]></title>
    <link href="http://defmys.github.io/blog/2015/12/21/new-and-and-init/"/>
    <updated>2015-12-21T17:48:09+08:00</updated>
    <id>http://defmys.github.io/blog/2015/12/21/new-and-and-init</id>
    <content type="html"><![CDATA[<p>既然是第一篇笔记，那就从Python的&#95;&#95;new&#95;&#95;和&#95;&#95;init&#95;&#95;开始吧。</p>

<p>以下内容均针对Python3</p>

<p>先上官方文档：<br />
<a href="https://docs.python.org/3/reference/datamodel.html#object.__new__">https://docs.python.org/3/reference/datamodel.html#object.__new__</a>
<a href="https://docs.python.org/3/reference/datamodel.html#object.__init__">https://docs.python.org/3/reference/datamodel.html#object.__init__</a></p>

<h2>__new__</h2>


<p>&#95;&#95;new&#95;&#95;是一个静态方法，被调用之后会返回一个新的object，类型为cls。如果需要自定义一些&#95;&#95;new&#95;&#95;的行为，注意不要忘了调用super().&#95;&#95;new&#95;&#95;(cls[, &hellip;])</p>

<figure class='code'><figcaption><span>example01</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">class</span> <span class="nc">TestClass</span><span class="p">:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TestClass</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span>
</span></code></pre></td></tr></table></div></figure>




<h2>__init__</h2>


<p>当一个对象被创建出来之后，即&#95;&#95;new&#95;&#95;执行之后，&#95;&#95;init&#95;&#95;会被调用。同样，如果基类中有&#95;&#95;init&#95;&#95;，并且派生类显示申明了&#95;&#95;init&#95;&#95;，那么必须调用super().&#95;&#95;init&#95;&#95;(self)</p>

<p>文档明确描述了执行顺序：
先调用&#95;&#95;new&#95;&#95;，生成一个对象。之后调用&#95;&#95;init&#95;&#95;。最后将这个对象返回给调用者。</p>

<h2>进阶</h2>


<p>接下来看一看CPython中这一部分的实现。版本为3.5.1。<br/>
以下代码略去一些步骤，只看我们关心的部分</p>

<figure class='code'><figcaption><span>typeobject.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="nf">type_call</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 略去一些检查</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// tp_new    </span>
</span><span class='line'>    <span class="c1">// https://docs.python.org/3.5/c-api/typeobj.html#c.PyTypeObject.tp_new</span>
</span><span class='line'>    <span class="n">obj</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_new</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kids</span><span class="p">);</span>    <span class="c1">// tp_new完成了一些初始化以及内存分配的工作</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 略去一些检查</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">type</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_init</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// tp_init    </span>
</span><span class='line'>            <span class="c1">// https://docs.python.org/3.5/c-api/typeobj.html#c.PyTypeObject.tp_init</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_init</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 略去一些检查</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>&#95;&#95;new&#95;&#95;和&#95;&#95;init&#95;&#95;都是在对象被创建出来时调用，都可以用来给对象做初始化。那么何时应该用&#95;&#95;new&#95;&#95;，何时应该用&#95;&#95;init&#95;&#95;呢？<br/>
以下是文档中的描述：</p>

<blockquote><p>The tp_new function should call subtype->tp_alloc(subtype, nitems) to allocate space for the object, and then do only as much further initialization as is absolutely necessary. Initialization that can safely be ignored or repeated should be placed in the tp_init handler. A good rule of thumb is that for immutable types, all initialization should take place in tp_new, while for mutable types, most initialization should be deferred to tp_init.</p><footer><strong>docs.python.org</strong> <cite><a href='https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new'>Type Objects</a></cite></footer></blockquote>


<p>可以看到，tp_new通常只做一些必须的初始化工作，而一些可以被安全的忽略或者可以被重复调用的初始化过程应该放在tp_init中。对于immutable tpyes(比如 int, tuple, string等)，初始化工作应该放在tp_new中；对于mutable types，最好放在tp_init中。</p>

<p>在上面的代码中省略了一些检查，其中有一部分比较有意思：<strong>在某些条件下，tp_init是不会被执行的。</strong>暂时不看这部分代码，我们直接从文档入手。<br/></p>

<blockquote><p>If the tp_new function returns an instance of some other type that is not a subtype of the original type, no tp_init function is called.</p><footer><strong>docs.python.org</strong> <cite><a href='https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_init'>Type Objects</a></cite></footer></blockquote>


<p>当tp_new返回了一个不是当前类型的对象，tp_init不会被调用。<br/>
下面我们做个简单的测试。</p>

<figure class='code'><figcaption><span>test01</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">class</span> <span class="nc">ClassWithInit</span><span class="p">:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithInit.__new__&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># 返回一个同类型的对象，之后应该会调用__init__</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ClassWithInit</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithInit.__init__&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ClassWithoutInit</span><span class="p">:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithoutInit.__new__&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># 返回了一个int，与当前类型不同，也不是派生类的对象，__init__应该不会被调用</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithoutInit.__init__&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">ClassWithInit</span><span class="p">()</span>
</span><span class='line'>    <span class="n">ClassWithoutInit</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果和预期相同：</p>

<figure class='code'><figcaption><span>output:test01</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ClassWithInit.__new__
</span><span class='line'>ClassWithInit.__init__
</span><span class='line'>ClassWithoutInit.__new__
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
