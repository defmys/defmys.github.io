
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>钟表匠</title>
  <meta name="author" content="Ma Tingchen">

  
  <meta name="description" content="对于闭包这个概念，以前有过一点点了解，但实际工作中并没有真正的去用，也没有仔细的去研究。此篇笔记就献给闭包了，好好整理一下概念与思路。 概念 先看一下维基百科上的定义：
A closure is a record storing a function together with an &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://defmys.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="钟表匠" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!--<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>-->
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->
<!--<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">-->
<link href="/stylesheets/gfonts1.css" rel="stylesheet" type="text/css">
<link href="/stylesheets/gfonts2.css" rel="stylesheet" type="text/css">

  

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-74059732-1', 'auto');
    ga('send', 'pageview');

  </script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">钟表匠</a></h1>
  
    <h2>立志成为专业造轮子的</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="defmys.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/05/04/closure-and-lambda-expression/">闭包及lambda表达式</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-05-04T15:45:36+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>4</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>3:45 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>
对于闭包这个概念，以前有过一点点了解，但实际工作中并没有真正的去用，也没有仔细的去研究。此篇笔记就献给闭包了，好好整理一下概念与思路。
</p>




<h2>概念</h2>


<p>
先看一下维基百科上的定义：
<blockquote><p>A closure is a record storing a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or storage location to which the name was bound when the closure was created.</p><footer><strong>Wikipeida</strong> <cite><a href='https://en.wikipedia.org/wiki/Closure_(computer_programming)'>Closure (Computer Programming)</a></cite></footer></blockquote>
</p>


<p>
简单的说，闭包可以看做是一个函数加上与其相关的封闭环境所组成的一个实例。例如：
<figure class='code'><figcaption><span>example_00</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">f</span>
</span><span class='line'>
</span><span class='line'><span class="n">closure1</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">closure2</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nb">print</span><span class="p">(</span><span class="n">closure1</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span><span class='line'><span class="nb">print</span><span class="p">(</span><span class="n">closure2</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>
</p>




<p>
输出：
<figure class='code'><figcaption><span>output</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>11
</span><span class='line'>21
</span></code></pre></td></tr></table></div></figure>
</p>




<p>
例子中的closure1与closure2就是两个闭包。
</p>


<p>
首先看closure函数，它接受一个参数x。当调用closure函数时，x被赋值，同时创建并返回函数对象f。x的作用域虽然为closure函数本身，但是由于f中还有x的引用，所以x并不会被释放，而仍然留在内存中。此时， 我们可以认为，被返回的不仅仅是f，<strong>还包括一个的封闭环境</strong>，x就存在于这个环境中。
</p>


<p>
所以对于closure1和closure2来说，他们不仅仅等于函数f，还包含了生成这两个对象时所创建出来的x对象。
</p>




<h2>用法</h2>


<h3>Python</h3>


<p>
前面的例子是用Python实现的一个闭包，不过还可以做一点点改进。例子中的f是在closure函数中定义的，我们可以用匿名函数来改写它。
<figure class='code'><figcaption><span>example_01</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">def</span> <span class="nf">closure</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span><span class='line'>
</span><span class='line'><span class="n">closure1</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</span><span class='line'><span class="n">closure2</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nb">print</span><span class="p">(</span><span class="n">closure1</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span><span class='line'><span class="nb">print</span><span class="p">(</span><span class="n">closure2</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>
</p>


<p>
输出：
<figure class='code'><figcaption><span>output</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>11
</span><span class='line'>21
</span></code></pre></td></tr></table></div></figure>
</p>


<p>
这样，我们就用python的lambda表达式构建出了闭包。
</p>




<h2>C++</h2>


<p>
C++11引入了lambda，可以与python一样方便的利用lambda创建闭包。
</p>


<p>
我们先看一下C++的lambda语法：<br />
<span style="font-size:12pt;">
[ capture-list ] ( params ) mutable(optional) constexpr(optional)(c++17) exception attribute -> ret {body }
<span>
</p>


<p>
其中：
<table>
<tr>
<td style="width: 20%;font-weight:bold;font-style:italic;">capture-list</td>
<td>捕获变量的列表。被捕获的变量可以在lambda表达式函数体中使用。</td>
</tr>
<tr>
<td style="width: 20%;font-weight:bold;font-style:italic;">params</td>
<td>lambda表达式的参数列表</td>
</tr>
<tr>
<td style="width: 20%;font-weight:bold;font-style:italic;">mutable</td>
<td>捕获变量时如果采用的是拷贝的方式，那么这些变量默认带const属性。加上mutable之后，可以去掉其const属性。</td>
</tr>
<tr>
<td style="width: 20%;font-weight:bold;font-style:italic;">ret</td>
<td>返回值类型</td>
</tr>
</table>
</p>


<p>
下面我们一步一步来用lambda表达式创建闭包。
</p>


<h4>1. 生成一个空的匿名函数</h4>


<p>
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">[](){};</span>
</span></code></pre></td></tr></table></div></figure>
</p>


<p>
这个lambda表达式的capture-list是空的，也就是说它不能使用任何外层作用域的变量。同时，其参数列表和函数体也是空的。<br />
对于不含有参数，即参数列表为空的lambda表达式，可以省略():
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">[]{};</span>
</span></code></pre></td></tr></table></div></figure>
</p>


<h4>2. 捕获变量</h4>


<p>
函数只是闭包的一部分，另一部分是封闭的环境。我们已经生成了一个空的匿名函数，但是并没有看到这个环境。下面，我们将一些变量放入这个封闭环境的中。假设x是一个int型的变量：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>
</p>


<p>
此时，我们就可以在函数体中使用x了。下面的例子说明x存在于封闭的环境中：
<figure class='code'><figcaption><span>example_02</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">closure</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">closure1</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">closure2</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">closure1</span><span class="p">();</span>
</span><span class='line'>    <span class="n">closure2</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</p>


<p>
和开头看到的python的例子类似，我们利用closure函数创建闭包。对于closure1和closure2两个闭包来说，他们不仅仅是由closure函数返回的匿名函数，同时还包含了x变量的拷贝（后面会解释为什么是拷贝）。
</p>


<p>
我们修改一下这个例子，使其实现和python例子完全一样的功能：
<figure class='code'><figcaption><span>example_03</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &lt;iostream&gt;</span>
</span><span class='line'><span class="cp">#include &lt;functional&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">closure</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">closure1</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">closure2</span> <span class="o">=</span> <span class="n">closure</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">closure1</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">closure2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
</p>


<p>
首先，lambda表达式被修改为：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="p">[</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
使其接受一个int型的参数y，计算并返回x+y。 -> int 表示返回值类型为int型。
</p>


<p>
之后，还需要修改一下closure函数的返回值类型。由于现在lambda表达式多了一个int型的参数，同时会返回int型的返回值，所以返回类型变为了
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>
</p>


<p>
严格的说，这并不是匿名函数的真实类型，不过我们写的lambda表达式可以被转换为<strong>std::function&lt;int(int)&gt;</strong>。
</p>


<p>
用python构建的闭包中变量x的生存周期是自动管理的。虽然外层的函数closure已经结束了，但是这个变量并不会被释放，直到闭包也被释放、且x的引用计数为0时才会被释放。<br />
而在c++中，问题就比较复杂了。前面的例子中，x变量是按值传递的，即x是原变量的拷贝。除了这种按值传递的方式之外，还有其他的方式可以捕获变量。
<table>
<tr>
<td style="width: 15%;">[]</td>
<td>- 什么变量都不捕获。</td>
</tr>
<tr>
<td style="width: 15%;">[=]</td>
<td>- 按值捕获在lambda表达式所在函数的函数体中提及的全部自动储存持续性变量</td>
</tr>
<tr>
<td style="width: 15%;">[&]</td>
<td>- 按引用捕获在lambda表达式所在函数的函数体中提及的全部自动储存持续性变量</td>
</tr>
<tr>
<td style="width: 15%;">[a,&b]</td>
<td>- 按值捕获a，按引用捕获b</td>
</tr>
<tr>
<td style="width: 15%;">[this]</td>
<td>- 按值捕获this指针</td>
</tr>
</table>
</p>


<p>
当我们使用[]时，即不捕获任何变量时，这个闭包的环境内是没有变量的。此时lambda表达式返回的是一个函数指针。而其他情况下，返回的是一个ClosureType对象，即闭包对象。
</p>


<p>分别来看几种捕获变量的情况：</p>

<h5>按值传递</h5>


<p>
在闭包对象中保存的变量是一份拷贝，闭包对象被销毁时这些对象也会被销毁。
</p>




<h5>按引用传递</h5>


<p>
闭包中保存的变量是原变量的引用。对闭包中这些变量进行修改会影响原始的变量，反之亦然。同时，原变量的生存周期也会影响到闭包中的变量，这里就有陷阱了。例如，我们修改一下例子中的lambda表达式，按引用捕获x
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">closure</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
这时候闭包中保存的x是引用，但是闭包对象被创建出来之后，closure函数的参数x会被释放，闭包中保存的引用也随之失效。这时就产生了dangling reference，并导致程序运行出现未定义的行为。
<p>
<blockquote><p><strong>Dangling references</strong><br /><br/>If an entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.<br/>Same applies to the lifetime of the object pointed to by the captured this pointer.</p><footer><strong>cppreference.com</strong> <cite><a href='http://en.cppreference.com/w/cpp/language/lambda'>Dangling References</a></cite></footer></blockquote>
</p>
所以，在使用闭包的过程中，需要仔细考虑变量的生存周期，避免引用和指针指向失效的地址。
</p>




<h2>扩展</h2>


<p>
C++的例子中，申明一个closure函数比较麻烦，同时，每次修改closure函数返回的lambda表达式时，都需要考虑是否需要修改返回值类型。我们的例子中，一开始返回值的类型是std::function<void(void)>，到最后修改为了std::function<int(int)>。在C++11中，auto对于函数返回值类型的推演并不是很方便，但是从C++14之后，我们可以直接写成
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">auto</span> <span class="nf">closure</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">](</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
这样不论怎么修改lambda表达式，我们都不用去关心返回值的类型了。
</p>




<h2></h2>


<h4>参考</h4>


<ul>
<li><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">Closure (computer programming) - Wikipedia</a></li>
<li><a href="http://en.cppreference.com/w/cpp/language/lambda">Lambda functions (since C++11) - cppreference.com</a></li>
</ul>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/02/18/coding-style/">Coding Style</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-02-18T15:32:45+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>3:32 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>
最近在整理前段时间写的代码。之前一直使用IDE进行检查，我使用的是PyCharm，能够使代码基本满足PEP8的要求。但还是有一些例外。利用其他工具检查的时候就能发现一些问题。我一直觉得代码必须要遵循一定的规则，以增强可读性。曾经看到过一句话，大概是说，代码是给人看的，至于如何让机器理解，那是编译器的工作。一般情况下公司对代码都会有一定的要求，不过是否严格执行就不一定了。在没有严格要求的情况下，纯靠自觉。。<br />
<ul>
    <li>C++可以参考<a href="https://google.github.io/styleguide/cppguide.html">Google C++ Style Guide</a></li>
    <li>Python主要参考<a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a> </li>
</ul>
</p>




<h2>PEP8</h2>


<p>
PEP8涵盖了命名规则、缩进、行长度等规则，也有不少工具可以自动进行检查。
</p>


<p>
其中比较有争议的是单行的最大长度。PEP8中规定一行代码的最大长度为79个字符，如果项目组内可以达成共识，可将长度扩展到99个字符。有一些编辑器默认会将行长度限制到80字符，超出限制之后会自动换行。换行之后代码会变得非常乱，影响阅读。将行长度限制到79个字符而不是80个字符是因为部分编辑器会显示出行尾的换行符，当一行有80个字符时，加上最后这个换行符，就会变成81个字符。这种情况下，编辑器可能会自动换行。另外，我也搜到了一些其他的文章，讨论“80个字符”这个限制的各种原因，包括终端显示、人阅读时的行为习惯等等。
</p>


<p>
将代码限制到79个字符是一个比较痛苦过程。PyCharm默认限制为120个字符，我也一直是按120字符去进行换行。重新限制了长度之后，有几百处代码需要修改。但修改完之后发现还是有很多好处的。比如可以同时开两个vim放在屏幕左右两边，阅读代码时不需要左右滚动；PyCharm中也可以左右开两个标签页；阅读时眼睛基本集中在一片区域等等。目前项目中还没有遇到无法修改到79个字符以内的代码。
</p>


<p>
至于其他规则，目前感觉没什么好纠结的。
</p>




<h2>Flake8</h2>


<p>
Flake8是一个执行python代码检查的工具集合。目前我使用Flake8来对项目代码进行检查。除PEP8之外，Flake8还会执行一些额外的检查。可以通过命令行参数调整flake8的行为，也可以将参数写入配置文件中。项目的setup.cfg中如果存在[flake8]的配置，flake8会自动读取这些配置。例如我们的setup.cfg文件中：
<figure class='code'><figcaption><span>setup.cfg</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[flake8]</span>
</span><span class='line'><span class="na">exclude</span> <span class="o">=</span> <span class="s">some_dir/*</span>
</span><span class='line'><span class="na">max-complexity</span> <span class="o">=</span> <span class="s">10</span>
</span></code></pre></td></tr></table></div></figure>
检查时会跳过some_dir，同时开启复杂度检查（默认是关闭的），允许的最大复杂度为10。
</p>


<p>
可以把flake8做成hook，提交代码之后自动进行检查。我们的项目一直使用jenkins做一些自动化的工作，任何一个任务执行失败之后会自动发邮件给相关人员，也能看到具体执行的命令和输出，非常方便。所以我直接把检查的步骤交给jenkins去做，每半个小时检查一次svn是否有更新，如果有更新，执行一次检查，如果出现错误，自动给这段时间提交过代码的人发邮件。
</p>




<h2>McCabe复杂度</h2>


<p>
Flake8中集成了<a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">McCabe复杂度（循环复杂度）</a>检查，默认情况下是关闭的。循环复杂度是一段代码中线性独立路径的数量。例如，一段代码中存在一个if语句，那么就存在true和false两种情况，对应就有两条路径。<br />
循环复杂度M定义为：<br /><br />
<strong>M = E - N + 2P</strong><br />
<img class="right" src="/images/Control_flow_graph_of_function_with_loop_and_an_if_statement_without_loop_back.svg" width="192" height="240" title="complexity example" >
<ul>
其中：
<li>E = 图中边的数量</li>
<li>N = 图中顶点的数量</li>
<li>P = 图中连通分支的数量</li>
</ul>
<br />

借用wikipedia中的一个例子：<br>

右图中有9条边，8个顶点，1个连通分支。E=9，N=8，P=1，所以循环复杂度M = 9 - 8 + 2*1 = 3
</p>




<p>
我们项目的代码使用MVC模式。View纯粹是前端的工作，对于只提供API的后端来说，只有M与C。Model与Model之间基本无耦合，逻辑比较清晰，在检查复杂度的时候基本没有问题，偶尔有一两处复杂度达到了11或12，简单修改之后就能降低到10以下。问题在于Controller。Controller将不同的Model在逻辑上联系在一起，对于逻辑上稍复杂一些的Controller，代码很容易写的很长，分支也很多。检查之后发现，复杂度高的基本都是Controller，最大的能达到26。写代码的时候没什么感觉，但是回过头再看这些代码的时候，发现真的是又长又难理解。经过一番重构之后，最终把所有代码的复杂度都降到了10以下。这样的重构带来的好处是使代码变得清晰易懂。我一直希望自己写的代码能满足self-documenting code的要求，简单易懂好维护，无需多余的注释。通过这次重构，我发现在降低复杂度的同时，代码能向着self-documenting的方向更进一步。降低复杂度时我将大段的、逻辑上可分离的分支抽取成函数，函数名即可表名这段代码的作用。逻辑主干上看到的只是这个函数名，而实现细节被封装了起来。阅读时看到函数名就等于是看到了一行注释，比直接阅读实现细节要清晰明了。
</p>




<h2></h2>


<p>
规范代码风格有时是一个比较痛苦的过程，但是带来的收益却是可观的。偶尔犯懒，对于不好修改的代码，总想加个例外。但静下心来修改完之后，再看这段代码，会发现其实并没有什么例外。自己认为不好修改的部分，很多时候其实是原本的实现存在问题。
<strong><em>Special cases aren't special enough to break the rules.</em></strong>
</p>


<p><br /></p>

<p>
最后，附上 The Zen of Python
<blockquote><p>Beautiful is better than ugly.<br/>Explicit is better than implicit.<br/>Simple is better than complex.<br/>Complex is better than complicated.<br/>Flat is better than nested.<br/>Sparse is better than dense.<br/>Readability counts.<br/>Special cases aren't special enough to break the rules.<br/>Although practicality beats purity.<br/>Errors should never pass silently.<br/>Unless explicitly silenced.<br/>In the face of ambiguity, refuse the temptation to guess.<br/>There should be one-- and preferably only one --obvious way to do it.<br/>Although that way may not be obvious at first unless you're Dutch.<br/>Now is better than never.<br/>Although never is often better than *right* now.<br/>If the implementation is hard to explain, it's a bad idea.<br/>If the implementation is easy to explain, it may be a good idea.<br/>Namespaces are one honking great idea -- let's do more of those!</p><footer><strong>The Zen of Python</strong> <cite><a href='https://www.python.org/dev/peps/pep-0020/'>PEP20</a></cite></footer></blockquote>
</p>




<h2>参考</h2>


<ul>
<li><a href="https://www.python.org/dev/peps/pep-0008/">PEP 0008 -- Style Guide for Python Code</a></li>
<li><a href="https://flake8.readthedocs.org/en/latest/">Flake8</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic complexity</a></li>
<li><a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">Connected component (graph theory)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Self-documenting_code">https://en.wikipedia.org/wiki/Self-documenting_code</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0020/">PEP 20 -- The Zen of Python</a></li>
</ul>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/05/metaclass/">Metaclass</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-05T10:36:01+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>10:36 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>
在Python中，任何东西都是对象。函数是对象，类也是对象，类的类也是对象。
<figure class='code'><figcaption><span>Example0.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span><span class='line'>    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'><span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
</span><span class='line'><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">))</span>
</span><span class='line'><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">foo</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>

输出：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>&lt;class <span class="s1">&#39;function&#39;</span>&gt;
</span><span class='line'>&lt;class <span class="s1">&#39;type&#39;</span>&gt;
</span><span class='line'>&lt;class <span class="s1">&#39;type&#39;</span>&gt;
</span></code></pre></td></tr></table></div></figure>

可以看到，foo是function的对象，function是type的对象，type是type的对象。
</p>


<h2>type</h2>


<p>type是python中的一个builtin类，并非关键字(<a href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">Python Keywords</a>)。<br />
有两种方式可以调用type，分别产生两种效果:</p>

<pre><code>* 当只有一个参数时，也就是上面例子中的用法，type返回参数中对象的类
* 当有三个参数时，type生成一个新的类。
</code></pre>

<p>我们只看第一种用法。以下是python3.5.1中的C实现：</p>

<figure class='code'><figcaption><span>typeobject.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="nf">type_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">metatype</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 省略部分代码</span>
</span><span class='line'>    <span class="cm">/* Special case: type(x) should return x-&gt;ob_type */</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">const</span> <span class="n">Py_ssize_t</span> <span class="n">nargs</span> <span class="o">=</span> <span class="n">PyTuple_GET_SIZE</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
</span><span class='line'>        <span class="k">const</span> <span class="n">Py_ssize_t</span> <span class="n">nkwds</span> <span class="o">=</span> <span class="n">kwds</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">PyDict_Size</span><span class="p">(</span><span class="n">kwds</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">PyType_CheckExact</span><span class="p">(</span><span class="n">metatype</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nargs</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nkwds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">PyObject</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">PyTuple_GET_ITEM</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="n">Py_INCREF</span><span class="p">(</span><span class="n">Py_TYPE</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</span><span class='line'>            <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="cm">/* SF bug 475327 -- if that didn&#39;t trigger, we need 3</span>
</span><span class='line'><span class="cm">           arguments. but PyArg_ParseTupleAndKeywords below may give</span>
</span><span class='line'><span class="cm">           a msg saying type() needs exactly 3. */</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">nargs</span> <span class="o">+</span> <span class="n">nkwds</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">PyErr_SetString</span><span class="p">(</span><span class="n">PyExc_TypeError</span><span class="p">,</span>
</span><span class='line'>                            <span class="s">&quot;type() takes 1 or 3 arguments&quot;</span><span class="p">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 省略部分代码</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到这里有一个特殊处理：当只args中只有一个参数时，type(x)会直接返回这一个参数的类。</p>




<h2>Metaclass</h2>


<p>通过type，我们可以知道一个对象的类究竟是什么。从第一个例子中可以看出，函数是function类的对象，类是type类的对象，type类自己也是type类的对象。<strong>类的类就是metaclass</strong>。</p>


<p>如果我们在创建一个类时，没有特别指明一个metaclass，那么这个类就会使用type类作为自己的metaclass。</p>


<p>类决定了对象的行为，同理，作为类的类，metaclass决定了一个类在生成对象时的行为。</p>




<p>
metaclass可以是任何可被调用的类型，类或者函数都可以。<br />
Python3为metaclass引入了一个新的函数:<strong>&#95;&#95;prepare&#95;&#95;</strong>，这个函数会在对象创建前被调用并返回一个字典。这个字典不一定是内置的dict，只要实现了部分必须的接口就可以。这个字典中存储了对象的成员。由于可以是自己实现的dict，我们可以对其进行各种操作。
</p>


<p>所以，通过&#95;&#95;prepare&#95;&#95;, &#95;&#95;new&#95;&#95;, &#95;&#95;init&#95;&#95;等函数，我们可以控制生成对象时的一些行为。</p>


<p>以下是PEP3115中的例子，最后稍做了一点改动，用来输出结果：</p>

<figure class='code'><figcaption><span>PEP3115_Example1.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='python3'><span class='line'><span class="c"># Here&#39;s a simple example of a metaclass which creates a list of</span>
</span><span class='line'><span class="c"># the names of all class members, in the order that they were</span>
</span><span class='line'><span class="c"># declared:</span>
</span><span class='line'>
</span><span class='line'><span class="c"># The custom dictionary</span>
</span><span class='line'><span class="k">class</span> <span class="nc">member_table</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">member_names</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># if the key is not already defined, add to the</span>
</span><span class='line'>        <span class="c"># list of keys.</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
</span><span class='line'>            <span class="bp">self</span><span class="o">.</span><span class="n">member_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># Call superclass</span>
</span><span class='line'>        <span class="nb">dict</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c"># The metaclass</span>
</span><span class='line'><span class="k">class</span> <span class="nc">OrderedClass</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># The prepare function</span>
</span><span class='line'>    <span class="nd">@classmethod</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__prepare__</span><span class="p">(</span><span class="n">metacls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">):</span> <span class="c"># No keywords in this case</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">member_table</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># The metaclass invocation</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">classdict</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># Note that we replace the classdict with a regular</span>
</span><span class='line'>        <span class="c"># dict before passing it to the superclass, so that we</span>
</span><span class='line'>        <span class="c"># don&#39;t continue to record member names after the class</span>
</span><span class='line'>        <span class="c"># has been created.</span>
</span><span class='line'>        <span class="n">result</span> <span class="o">=</span> <span class="nb">type</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">classdict</span><span class="p">))</span>
</span><span class='line'>        <span class="n">result</span><span class="o">.</span><span class="n">member_names</span> <span class="o">=</span> <span class="n">classdict</span><span class="o">.</span><span class="n">member_names</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">OrderedClass</span><span class="p">):</span>
</span><span class='line'>    <span class="c"># method1 goes in array element 0</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">method1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>    <span class="c"># method2 goes in array element 1</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">method2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">MyClass</span><span class="p">()</span><span class="o">.</span><span class="n">member_names</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="o">[</span><span class="s1">&#39;__module__&#39;</span>, <span class="s1">&#39;__qualname__&#39;</span>, <span class="s1">&#39;method1&#39;</span>, <span class="s1">&#39;method2&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>该例子中：</p>

<pre><code>1. 创建了一个member_table，继承自dict并重载了__setitem__函数，按顺序记录所有key。
2. 声明了一个新的metaclass -- OrderedClass。
    2.1 __prepare__函数返回一个member_table对象
    2.2 __new__函数中将member_table里记录的key复制给自己的一个成员变量member_names。
3. 申明了一个metaclass为OrderedClass的类，声明两个成员函数。这两个成员函数的名称会被存储在member_names中。
</code></pre>

<p>当一个对象被创建时，以下工作会被按顺序执行</p>

<blockquote><p>When a class definition is executed, the following steps occur:</p><p>    * the appropriate metaclass is determined<br/>    * the class namespace is prepared<br/>    * the class body is executed<br/>    * the class object is created</p><footer><strong>docs.python.org</strong> <cite><a href='https://docs.python.org/3/reference/datamodel.html#customizing-class-creation'>Customizing Class Creation</a></cite></footer></blockquote>




<p>以下是对应的代码：
<figure class='code'><figcaption><span>Lib/types.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="c"># Provide a PEP 3115 compliant mechanism for class creation</span>
</span><span class='line'><span class="k">def</span> <span class="nf">new_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwds</span><span class="o">=</span><span class="k">None</span><span class="p">,</span> <span class="n">exec_body</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;Create a class object dynamically using the appropriate metaclass.&quot;&quot;&quot;</span>
</span><span class='line'>    <span class="n">meta</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">kwds</span> <span class="o">=</span> <span class="n">prepare_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">kwds</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">exec_body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="k">None</span><span class="p">:</span>
</span><span class='line'>        <span class="n">exec_body</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">meta</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">prepare_class</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="o">=</span><span class="p">(),</span> <span class="n">kwds</span><span class="o">=</span><span class="k">None</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;Call the __prepare__ method of the appropriate metaclass.</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    Returns (metaclass, namespace, kwds) as a 3-tuple</span>
</span><span class='line'>
</span><span class='line'><span class="sd">    *metaclass* is the appropriate metaclass</span>
</span><span class='line'><span class="sd">    *namespace* is the prepared class namespace</span>
</span><span class='line'><span class="sd">    *kwds* is an updated copy of the passed in kwds argument with any</span>
</span><span class='line'><span class="sd">    &#39;metaclass&#39; entry removed. If no kwds argument is passed in, this will</span>
</span><span class='line'><span class="sd">    be an empty dict.</span>
</span><span class='line'><span class="sd">    &quot;&quot;&quot;</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">kwds</span> <span class="ow">is</span> <span class="k">None</span><span class="p">:</span>
</span><span class='line'>        <span class="n">kwds</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span> <span class="c"># Don&#39;t alter the provided mapping</span>
</span><span class='line'>    <span class="k">if</span> <span class="s">&#39;metaclass&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
</span><span class='line'>        <span class="n">meta</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;metaclass&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">bases</span><span class="p">:</span>
</span><span class='line'>            <span class="n">meta</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'>        <span class="k">else</span><span class="p">:</span>
</span><span class='line'>            <span class="n">meta</span> <span class="o">=</span> <span class="nb">type</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
</span><span class='line'>        <span class="c"># when meta is a type, we first determine the most-derived metaclass</span>
</span><span class='line'>        <span class="c"># instead of invoking the initial candidate directly</span>
</span><span class='line'>        <span class="n">meta</span> <span class="o">=</span> <span class="n">_calculate_meta</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="n">bases</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">meta</span><span class="p">,</span> <span class="s">&#39;__prepare__&#39;</span><span class="p">):</span>
</span><span class='line'>        <span class="n">ns</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">__prepare__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span><span class="p">:</span>
</span><span class='line'>        <span class="n">ns</span> <span class="o">=</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">meta</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">kwds</span>
</span></code></pre></td></tr></table></div></figure>

以上代码解释了metaclass中的&#95;&#95;prepare&#95;&#95;在何时被调用以及完成了哪些工作。</p>




<p>再简单看一下metaclass在type_new函数中如何工作。以下代码只保留了我们关心的部分。
<figure class='code'><figcaption><span>typeobject.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="nf">type_new</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">metatype</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// ..........................</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Determine the proper metatype to deal with this: */</span>
</span><span class='line'>    <span class="n">winner</span> <span class="o">=</span> <span class="n">_PyType_CalculateMetaclass</span><span class="p">(</span><span class="n">metatype</span><span class="p">,</span> <span class="n">bases</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">winner</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">winner</span> <span class="o">!=</span> <span class="n">metatype</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">winner</span><span class="o">-&gt;</span><span class="n">tp_new</span> <span class="o">!=</span> <span class="n">type_new</span><span class="p">)</span> <span class="cm">/* Pass it to the winner */</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">winner</span><span class="o">-&gt;</span><span class="n">tp_new</span><span class="p">(</span><span class="n">winner</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">);</span>
</span><span class='line'>        <span class="n">metatype</span> <span class="o">=</span> <span class="n">winner</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// ............................</span>
</span><span class='line'>
</span><span class='line'>     <span class="cm">/* Allocate the type object */</span>
</span><span class='line'>    <span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="p">)</span><span class="n">metatype</span><span class="o">-&gt;</span><span class="n">tp_alloc</span><span class="p">(</span><span class="n">metatype</span><span class="p">,</span> <span class="n">nslots</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>        <span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// ..............................</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="n">PyObject</span> <span class="o">*</span><span class="p">)</span><span class="n">type</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

首先还是选取一个合适的metaclass，如果选出的metaclass不是当前参数中的metatype，那么执行选出的metatype->tp_new。然后为类申请空间、进行初始化工作。最后返回该类。</p>




<h2>实践</h2>


<p>最后，我们用metaclass来实现一个简单的singleton。
<figure class='code'><figcaption><span>Example2.py</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">class</span> <span class="nc">Singleton</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
</span><span class='line'>    <span class="n">instance</span> <span class="o">=</span> <span class="k">None</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
</span><span class='line'>        <span class="k">if</span> <span class="ow">not</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span><span class="p">:</span>
</span><span class='line'>            <span class="n">cls</span><span class="o">.</span><span class="n">instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">instance</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ASingleton</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Singleton</span><span class="p">):</span>
</span><span class='line'>    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">BSingleton</span><span class="p">(</span><span class="n">metaclass</span><span class="o">=</span><span class="n">Singleton</span><span class="p">):</span>
</span><span class='line'>    <span class="k">pass</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">a1</span> <span class="o">=</span> <span class="n">ASingleton</span><span class="p">()</span>
</span><span class='line'>    <span class="n">a2</span> <span class="o">=</span> <span class="n">ASingleton</span><span class="p">()</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;a1 is a2? %s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a1</span> <span class="ow">is</span> <span class="n">a2</span><span class="p">))</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">a2</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;===============&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">b</span> <span class="o">=</span> <span class="n">BSingleton</span><span class="p">()</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="s">&#39;a1 is b? %s&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a1</span> <span class="ow">is</span> <span class="n">b</span><span class="p">))</span>
</span><span class='line'>    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">__class__</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>

输出：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>a1 is a2? True
</span><span class='line'>ASingleton
</span><span class='line'><span class="nv">ASingleton</span>
</span><span class='line'><span class="o">===============</span>
</span><span class='line'>a1.instance is ASingleton.instance?
</span><span class='line'><span class="nv">True</span>
</span><span class='line'><span class="o">===============</span>
</span><span class='line'>a1 is b? False
</span><span class='line'>BSingleton
</span></code></pre></td></tr></table></div></figure>

</p>


<p>
在这个例子中，我们创建了一个名为Singleton的metaclass。Singleton带有一个静态成员变量instance。在调用ASingleton或BSingleton创建对象时，会先检查instance是否为空。<br />需要注意的是，在第一次调用时，我们访问的是metaclass的静态成员变量instance。当对象被创建出来之后，这个对象会被赋值给各自class的instance（注意__call__的第一个参数 cls）。之后再通过ASingleton或BSingleton创建对象时，访问的是它们各自的类的instance，而不是metaclass的instance。<br />另外，由于使用的是类的instance，即相当于该class的静态成员变量，而不是生成出的对象的成员变量，所以相同的类的object所访问的都是同一个instance。
</p>




<h2></h2>


<h4>参考：</h4>


<ul>
<li><a href="https://www.python.org/dev/peps/pep-3115/">PEP 3115 -- Metaclasses in Python 3000</a></li>
<li><a href="https://docs.python.org/3/reference/datamodel.html#customizing-class-creation">Data model - Python 3.5.1 documentation</a></li>
<li><a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python">oop - What is a metaclass in Python? - Stack Overflow</a></li>
<li><a href="http://blog.ionelmc.ro/2015/02/09/understanding-python-metaclasses/">Understanding Python metaclasses | ionel's codelog</a></li>
<li><a href="https://en.wikibooks.org/wiki/Python_Programming/Metaclasses">Python Programming/Metaclasses - Wikibooks, open books for an open world</a></li>
<li><a href="http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html">Metaprogramming - Python 3 Patterns, Recipes and Idioms</a></li>
</ul>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/12/21/new-and-and-init/">__new__ &amp;&amp; __init__</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-12-21T17:48:09+08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>5:48 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>既然是第一篇笔记，那就从Python的&#95;&#95;new&#95;&#95;和&#95;&#95;init&#95;&#95;开始吧。</p>

<p>以下内容均针对Python3</p>

<p>先上官方文档：<br />
<a href="https://docs.python.org/3/reference/datamodel.html#object.__new__">https://docs.python.org/3/reference/datamodel.html#object.__new__</a>
<a href="https://docs.python.org/3/reference/datamodel.html#object.__init__">https://docs.python.org/3/reference/datamodel.html#object.__init__</a></p>

<h2>__new__</h2>


<p>&#95;&#95;new&#95;&#95;是一个静态方法，被调用之后会返回一个新的object，类型为cls。如果需要自定义一些&#95;&#95;new&#95;&#95;的行为，注意不要忘了调用super().&#95;&#95;new&#95;&#95;(cls[, &hellip;])</p>

<figure class='code'><figcaption><span>example01</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">class</span> <span class="nc">TestClass</span><span class="p">:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TestClass</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">obj</span>
</span></code></pre></td></tr></table></div></figure>




<h2>__init__</h2>


<p>当一个对象被创建出来之后，即&#95;&#95;new&#95;&#95;执行之后，&#95;&#95;init&#95;&#95;会被调用。同样，如果基类中有&#95;&#95;init&#95;&#95;，并且派生类显示申明了&#95;&#95;init&#95;&#95;，那么必须调用super().&#95;&#95;init&#95;&#95;(self)</p>

<p>文档明确描述了执行顺序：
先调用&#95;&#95;new&#95;&#95;，生成一个对象。之后调用&#95;&#95;init&#95;&#95;。最后将这个对象返回给调用者。</p>

<h2>进阶</h2>


<p>接下来看一看CPython中这一部分的实现。版本为3.5.1。<br/>
以下代码略去一些步骤，只看我们关心的部分</p>

<figure class='code'><figcaption><span>typeobject.c</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">PyObject</span> <span class="o">*</span>
</span><span class='line'><span class="nf">type_call</span><span class="p">(</span><span class="n">PyTypeObject</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">PyObject</span> <span class="o">*</span><span class="n">kwds</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 略去一些检查</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// tp_new    </span>
</span><span class='line'>    <span class="c1">// https://docs.python.org/3.5/c-api/typeobj.html#c.PyTypeObject.tp_new</span>
</span><span class='line'>    <span class="n">obj</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_new</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kids</span><span class="p">);</span>    <span class="c1">// tp_new完成了一些初始化以及内存分配的工作</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 略去一些检查</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">type</span> <span class="o">=</span> <span class="n">Py_TYPE</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_init</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// tp_init    </span>
</span><span class='line'>            <span class="c1">// https://docs.python.org/3.5/c-api/typeobj.html#c.PyTypeObject.tp_init</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">type</span><span class="o">-&gt;</span><span class="n">tp_init</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 略去一些检查</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>&#95;&#95;new&#95;&#95;和&#95;&#95;init&#95;&#95;都是在对象被创建出来时调用，都可以用来给对象做初始化。那么何时应该用&#95;&#95;new&#95;&#95;，何时应该用&#95;&#95;init&#95;&#95;呢？<br/>
以下是文档中的描述：</p>

<blockquote><p>The tp_new function should call subtype->tp_alloc(subtype, nitems) to allocate space for the object, and then do only as much further initialization as is absolutely necessary. Initialization that can safely be ignored or repeated should be placed in the tp_init handler. A good rule of thumb is that for immutable types, all initialization should take place in tp_new, while for mutable types, most initialization should be deferred to tp_init.</p><footer><strong>docs.python.org</strong> <cite><a href='https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new'>Type Objects</a></cite></footer></blockquote>


<p>可以看到，tp_new通常只做一些必须的初始化工作，而一些可以被安全的忽略或者可以被重复调用的初始化过程应该放在tp_init中。对于immutable tpyes(比如 int, tuple, string等)，初始化工作应该放在tp_new中；对于mutable types，最好放在tp_init中。</p>

<p>在上面的代码中省略了一些检查，其中有一部分比较有意思：<strong>在某些条件下，tp_init是不会被执行的。</strong>暂时不看这部分代码，我们直接从文档入手。<br/></p>

<blockquote><p>If the tp_new function returns an instance of some other type that is not a subtype of the original type, no tp_init function is called.</p><footer><strong>docs.python.org</strong> <cite><a href='https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_init'>Type Objects</a></cite></footer></blockquote>


<p>当tp_new返回了一个不是当前类型的对象，tp_init不会被调用。<br/>
下面我们做个简单的测试。</p>

<figure class='code'><figcaption><span>test01</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='py3'><span class='line'><span class="k">class</span> <span class="nc">ClassWithInit</span><span class="p">:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithInit.__new__&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># 返回一个同类型的对象，之后应该会调用__init__</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ClassWithInit</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithInit.__init__&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ClassWithoutInit</span><span class="p">:</span>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithoutInit.__new__&#39;</span><span class="p">)</span>
</span><span class='line'>        <span class="c"># 返回了一个int，与当前类型不同，也不是派生类的对象，__init__应该不会被调用</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="nb">print</span><span class="p">(</span><span class="s">&#39;ClassWithoutInit.__init__&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
</span><span class='line'>    <span class="n">ClassWithInit</span><span class="p">()</span>
</span><span class='line'>    <span class="n">ClassWithoutInit</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果和预期相同：</p>

<figure class='code'><figcaption><span>output:test01</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ClassWithInit.__new__
</span><span class='line'>ClassWithInit.__init__
</span><span class='line'>ClassWithoutInit.__new__
</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/05/04/closure-and-lambda-expression/">闭包及lambda表达式</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/18/coding-style/">Coding Style</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/05/metaclass/">Metaclass</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/21/new-and-and-init/">__new__ &amp;&amp; __init__</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Ma Tingchen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
